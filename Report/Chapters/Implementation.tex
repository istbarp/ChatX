\chapter{Implementation}

The implementation section below will explain what technologies were used and how they were implemented into ChatX.

\section{Code Standards}
Since this project makes use of two different programming languages it would be unwise to not set a code standard. So a code standard was set for each programming language.

\subsection{Java}
Class names must start with a capital letter.
Variables must start with lowercase letters, private ones should be refereed by using ".this".
Curly brackets are to be in their own lines at all times.
Method names must start with a lowercase letter.


\subsection{C\#}
Class names must start a capital letter.
Variables must start with lowercase letters, private ones should be refereed by using ".this".
Curly brackets are to be in their own lines at all times.
Method names must start with a capital letter.

\section{Client}
The client is what the person at home will use to use the chat system. The client is written in Java to make sure that the most amount of people would be able to run it. Java is not the fastest programming langauge, but is able to run on pretty much anything since it runs in an emulator and is not platform specific.

Since the server hosts a WCF service, a lot of code can be auto-generated using the eclipse web-service client which looks at the meta-data found in the XML sheet that the WCF service provides. When thats done everything else is just graphics related and how we want the user experience to be. Since the client side does not hold a lot of code, it is small in terms of download size, and will be easily accessible for everyone.

In terms of use there will be a couple of dialogs to begin with, to make sure that people enter a user-name and selects a room. When that is done people can then use the textbox to chat. This is not the final graphical layout, since it has a lot of issues in terms of user friendliness, but a premature version to check if everything is working.


\subsection{Web Client}

The web client will be what caters to most people since it's a thing that can be used on all platforms, such as phones, pc's, and even consoles. It will be the most difficult to make as well since it requires AJAX (Update a website without reloading).

\section{Cryptography}

To make the communication secure the clients implements an RSA encryption to encrypt all messages sent. RSA is a Public- Private key (asymmetric) encryption algorithm. RSA encryption is a standard for encrypting and is practically impossible to decode due to prime factorization. The general idea is that it is easy to find the product of two large primes, but it is hard to factor a large product and find the primes.

RSA was originally made by Ronald Linn Rivest along with Adi Shamir and Len Adlemanand published in their paper A Method for Obtaining Digital Signatures and Public-Key Cryptosystems\cite{RSA}.

To be able to apply RSA encryption, 6 variables are needed; $d$, $e$, $n$, $p$, $q$ and $\varphi$(phi). $d$, $p$, $q$ and $\varphi$(phi) should be kept secret at all time to keep this encryption secure. Let $p$ and $q$ be a prime number, lets for simplicity say $p=7$ and $q=13$. In practice these 2 numbers would be larger depending on the numbers of bits used for encryption. $n$ is defined as in equation \ref{RSA:n}.

\begin{equation}
n = p \times q
\label{RSA:n}
\end{equation}

In this case $n=91$. Additional $n$ have the bit-length dependent on security of the encryption. If the encryption should be 1024 bit, when $n$ would be a 1024 bit number. $\varphi$ or $\varphi(n)$ is found by using equation \ref{RSA:phi}.

\begin{equation}
\varphi = (p-1)(q-1)
\label{RSA:phi}
\end{equation}

For this example $\varphi = 72$ and it is now possible to find $e$ which is the public exponent. $e$ is a random prime and have two requirements which must be met; $e$ must be a relative prime of $\varphi$, ie. $e$ and $\varphi$ have no common factors and $e$ must be an integer such that $1 < e < \varphi$. For this example let $e=7$. The public key is now available as $n$ and $e$ is known and can be given out.

Lastly we calculate $d$ which is the private exponent using extended euclidean algorithm. Equation \ref{RSA:d} is used for finding $d$.

%https://www.youtube.com/watch?v=moqmFy39Itc
\begin{equation}
d = e^{-1} \textrm{ mod } \varphi
\label{RSA:d}
\end{equation}

From equation \ref{RSA:d} $d=31$ and it is possible to further check if this is correct by using equation \ref{RSA:check} which in this case it is, and the private key is now defined by $n$ and $d$.

\begin{equation}
e \times d \textrm{ mod } n = 1
\label{RSA:check}
\end{equation}

Now where both the public and private keys are assigned, they can be used to encrypt and decrypt messages. If the message "Hi" were to be decrypted it would first need to be translated into a number, eg. as 8 and 9. It is now possible to encrypt both letter individually by using equation \ref{RSA:Encrypt} which gives the output cipher text $C$, and as well as decrypt it again with equation \ref{RSA:Decrypt}.

\begin{equation}
C=M^e \textrm{ mod } n \quad \textrm{Where M $<$ n}
\label{RSA:Encrypt}
\end{equation}

\begin{equation}
M=C^d \textrm{ mod } n
\label{RSA:Decrypt}
\end{equation}

In the computer world when encrypting data, a padding is often used. Padding is often used to fill out byte blocks. For instance, if the message "Hi!" would had the byte block [48 69 21]. This block size is only of 3 bytes, but the encryption algorithm might read a block of 8 at a time which would mean the block needs 5 more bytes. There is multiple way of padding a message, such as zero-padding [48 69 21 00 00 00 00 00], padding with the same value as the number of bytes [48 69 21 05 05 05 05 05]\cite{PADDING}. When the padding is done a block can be sent to the encryption algorithm to produce the cipher text.

\section{Server}

\section{Webservice}

\section{RabbitMQ}