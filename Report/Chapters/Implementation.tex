\chapter{Implementation}

The implementation section below will explain what technologies were used and how they were implemented into ChatX.

\section{Code Standards}
Since this project makes use of two different programming languages it would be unwise to not set a code standard. So a code standard was set for each programming language.

\subsection{Java}
Class names must start with a capital letter.
Variables must start with lowercase letters, private ones should be refereed by using ".this".
Curly brackets are to be in their own lines at all times.
Method names must start with a lowercase letter.


\subsection{C\#}
Class names must start a capital letter.
Variables must start with lowercase letters, private ones should be refereed by using ".this".
Curly brackets are to be in their own lines at all times.
Method names must start with a capital letter.

\section{Client}
The "Client" is what the person at home will use to use the chat system. There will be two different clients to cater to as many as possible.

\subsection{Java Client}

The java client has been written as the first client and will be used as the test client as it is possible to have a console application.

\subsection{Web Client}

The web client will be what caters to most people since it's a thing that can be used on all platforms, such as phones, pc's, and even consoles. It will be the most difficult to make as well since it requires AJAX (Update a website without reloading).

\section{Cryptography}

To make the communication secure the clients implements an RSA encryption to encrypt all messages sent. RSA is a Public- Private key (asymmetric) encryption algorithm. RSA encryption is a standard for encrypting and is practically impossible to decode due to prime factorization. The general idea is that it is easy to find the product of two large primes, but it is hard to factor a large product and find the primes.

RSA was originally made by Ronald Linn Rivest along with Adi Shamir and Len Adlemanand published in their paper A Method for Obtaining Digital Signatures and Public-Key Cryptosystems\cite{RSA}.

To be able to apply RSA encryption, 6 variables are needed; $d$, $e$, $n$, $p$, $q$ and $\varphi$(phi). $d$, $p$, $q$ and $\varphi$(phi) should be kept secret at all time to keep this encryption secure. Let $p$ and $q$ be a prime number, lets for simplicity say $p=7$ and $q=13$. In practice these 2 numbers would be larger depending on the numbers of bits used for encryption. $n$ is defined as in equation \ref{RSA:n}.

\begin{equation}
n = p \times q
\label{RSA:n}
\end{equation}

In this case $n=91$. Additional $n$ have the bit-length dependent on security of the encryption. If the encryption should be 1024 bit, when $n$ would be a 1024 bit number. $\varphi$ or $\varphi(n)$ is found by using equation \ref{RSA:phi}.

\begin{equation}
\varphi = (p-1)(q-1)
\label{RSA:phi}
\end{equation}

For this example $\varphi = 72$ and it is now possible to find $e$ which is the public exponent. $e$ is a random prime and have two requirements which must be met; $e$ must be a relative prime of $\varphi$, ie. $e$ and $\varphi$ have no common factors and $e$ must be an integer such that $1 < e < \varphi$. For this example let $e=7$. The public key is now available as $n$ and $e$ is known and can be given out.

Lastly we calculate $d$ which is the private exponent using extended euclidean algorithm. Equation \ref{RSA:d} is used for finding $d$.

%https://www.youtube.com/watch?v=moqmFy39Itc
\begin{equation}
d = e^{-1} \textrm{ mod } \varphi
\label{RSA:d}
\end{equation}

From equation \ref{RSA:d} $d=31$ and it is possible to further check if this is correct by using equation \ref{RSA:check} which in this case it is, and the private key is now defined by $n$ and $d$.

\begin{equation}
e \times d \textrm{ mod } n = 1
\label{RSA:check}
\end{equation}

Now where both the public and private keys are assigned, they can be used to encrypt and decrypt messages. If the message "Hi" were to be decrypted it would first need to be translated into a number, eg. as 8 and 9. It is now possible to encrypt both letter individually by using equation \ref{RSA:Encrypt} which gives the output cipher text $C$, and as well as decrypt it again with equation \ref{RSA:Decrypt}.

\begin{equation}
C=M^e \textrm{ mod } n \quad \textrm{Where M $<$ n}
\label{RSA:Encrypt}
\end{equation}

\begin{equation}
M=C^d \textrm{ mod } n
\label{RSA:Decrypt}
\end{equation}

In the computer world when encrypting data, a padding is often used. Padding is often used to fill out byte blocks. For instance, if the message "Hi!" would had the byte block [48 69 21]. This block size is only of 3 bytes, but the encryption algorithm might read a block of 8 at a time which would mean the block needs 5 more bytes. There is multiple way of padding a message, such as zero-padding [48 69 21 00 00 00 00 00], padding with the same value as the number of bytes [48 69 21 05 05 05 05 05]\cite{PADDING}. When the padding is done a block can be sent to the encryption algorithm to produce the cipher text.

\section{Server}

\section{Webservice}
The webservice written in C\#, and is implemented using Windows Communication Foundation (WCF). 

The function of webservice is to be a broker between the client and the server(s); whenever a client interacts with the system, be it sending a message or requesting a list of rooms, it needs to go through this service. The service will then  contact the server(s) through a queue system, currently RabbitMQ, through which the servers also sends their response. The communication can be seen in figure:



\section{RabbitMQ}